# -*- coding: utf-8 -*-
"""gaff_pattern_reconiton.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FeaYGCw5FqP_ctloyAT6UTZRA89sD5Cm
"""

# Enhanced GAF Pattern Recognition & Forecasting for CDSL
# Added historical pattern success analysis and bullish condition detection

import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf

# Optional heavy dependencies - import safely
try:
    from sklearn.preprocessing import MinMaxScaler
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import classification_report
    _HAS_SKLEARN = True
except Exception:
    MinMaxScaler = None
    train_test_split = None
    classification_report = None
    _HAS_SKLEARN = False

try:
    import tensorflow as tf
    from tensorflow.keras.models import Sequential  # type: ignore[reportMissingImports]
    from tensorflow.keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, LSTM, Dropout  # type: ignore[reportMissingImports]
    from tensorflow.keras.optimizers import Adam  # type: ignore[reportMissingImports]
    _HAS_TF = True
except Exception:
    tf = None
    Sequential = None
    Dense = None
    Conv2D = None
    MaxPooling2D = None
    Flatten = None
    LSTM = None
    Dropout = None
    Adam = None
    _HAS_TF = False
import warnings
warnings.filterwarnings('ignore')

if _HAS_TF:
    try:
        tf.get_logger().setLevel('ERROR')
    except Exception:
        pass

class EnhancedCDSLPatternAnalyzer:
    def __init__(self, window_size=20):
        self.window_size = window_size
        # Only instantiate scaler if sklearn is available
        self.scaler = MinMaxScaler() if _HAS_SKLEARN and MinMaxScaler is not None else None
        self.pattern_model = None
        self.forecast_model = None
        self.historical_patterns = []
        # manual scaler fallback (min,max) when sklearn not available
        self._manual_scaler = None

    def fetch_data(self, symbol='PCJEWELLER.NS', period='2y'):  # Extended to 2 years for better analysis
        """Fetch CDSL stock data"""
        print(f"üìà Fetching {symbol} data...")
        try:
            stock = yf.Ticker(symbol)
            data = stock.history(period=period)
            if len(data) == 0:
                print("‚ùå No data found. Trying without .NS suffix...")
                stock = yf.Ticker('CDSL')
                data = stock.history(period=period)
            print(f"‚úÖ Data fetched: {len(data)} days")
            return data
        except Exception as e:
            print(f"‚ùå Error fetching data: {e}")
            return None

    def calculate_technical_indicators(self, data):
        """Calculate technical indicators for pattern context"""
        # RSI
        delta = data['Close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        data['RSI'] = 100 - (100 / (1 + rs))

        # Moving Averages
        data['SMA_20'] = data['Close'].rolling(window=20).mean()
        data['SMA_50'] = data['Close'].rolling(window=50).mean()
        data['EMA_12'] = data['Close'].ewm(span=12).mean()
        data['EMA_26'] = data['Close'].ewm(span=26).mean()

        # MACD
        data['MACD'] = data['EMA_12'] - data['EMA_26']
        data['MACD_Signal'] = data['MACD'].ewm(span=9).mean()
        data['MACD_Histogram'] = data['MACD'] - data['MACD_Signal']

        # Bollinger Bands
        data['BB_Middle'] = data['Close'].rolling(window=20).mean()
        bb_std = data['Close'].rolling(window=20).std()
        data['BB_Upper'] = data['BB_Middle'] + (bb_std * 2)
        data['BB_Lower'] = data['BB_Middle'] - (bb_std * 2)

        # Volume indicators
        data['Volume_SMA'] = data['Volume'].rolling(window=20).mean()
        data['Volume_Ratio'] = data['Volume'] / data['Volume_SMA']

        # Support and Resistance levels
        data['Support'] = data['Low'].rolling(window=20).min()
        data['Resistance'] = data['High'].rolling(window=20).max()

        return data

    def detect_inverted_w_pattern(self, prices, tolerance=0.03):
        """Enhanced inverted W detection with context"""
        patterns = []
        n = len(prices)

        for i in range(10, min(n-10, len(prices))):
            try:
                window_start = max(0, i-10)
                window_end = min(n, i+10)
                window = prices[window_start:window_end]

                if len(window) < 10:
                    continue

                local_mins = []
                for j in range(2, len(window)-2):
                    if (window[j] < window[j-1] and window[j] < window[j+1] and
                        window[j] < window[j-2] and window[j] < window[j+2]):
                        local_mins.append((j + window_start, window[j]))

                if len(local_mins) >= 2:
                    for k in range(len(local_mins)-1):
                        min1_idx, min1_val = local_mins[k]
                        min2_idx, min2_val = local_mins[k+1]

                        if (abs(min1_val - min2_val) / min1_val <= tolerance and
                            min2_idx - min1_idx > 5):
                            patterns.append({
                                'start_idx': min1_idx,
                                'end_idx': min2_idx + 5,
                                'pattern': 'inverted_w',
                                'confidence': 1 - (abs(min1_val - min2_val) / min1_val),
                                'min1_idx': min1_idx,
                                'min2_idx': min2_idx,
                                'min1_val': min1_val,
                                'min2_val': min2_val
                            })
                            break
            except IndexError:
                continue

        return patterns

    def detect_bullish_engulfing(self, data):
        """Enhanced bullish engulfing with volume confirmation"""
        patterns = []
        opens = data['Open'].values
        closes = data['Close'].values
        volumes = data['Volume'].values

        for i in range(1, min(len(closes), len(opens))):
            try:
                if (closes[i-1] < opens[i-1] and
                    closes[i] > opens[i] and
                    opens[i] < closes[i-1] and
                    closes[i] > opens[i-1]):

                    # Volume confirmation
                    volume_confirmation = volumes[i] > volumes[i-1] * 1.2 if i > 0 else False

                    patterns.append({
                        'start_idx': i-1,
                        'end_idx': i+1,
                        'pattern': 'bullish_engulfing',
                        'confidence': 0.9 if volume_confirmation else 0.7,
                        'volume_confirmed': volume_confirmation
                    })
            except IndexError:
                continue

        return patterns

    def detect_ascending_triangle(self, prices):
        """Enhanced ascending triangle detection"""
        patterns = []
        n = len(prices)

        for i in range(20, min(n-10, len(prices))):
            try:
                window_start = max(0, i-20)
                window_end = min(n, i)
                window = prices[window_start:window_end]

                if len(window) < 15:
                    continue

                highs, lows = [], []
                high_indices, low_indices = [], []

                for j in range(2, len(window)-2):
                    if window[j] > window[j-1] and window[j] > window[j+1]:
                        highs.append(window[j])
                        high_indices.append(j + window_start)
                    elif window[j] < window[j-1] and window[j] < window[j+1]:
                        lows.append(window[j])
                        low_indices.append(j + window_start)

                if len(highs) >= 3 and len(lows) >= 3:
                    if (np.std(highs) / np.mean(highs) < 0.02 and
                        np.mean(lows[-2:]) > np.mean(lows[:2])):

                        patterns.append({
                            'start_idx': window_start,
                            'end_idx': window_end,
                            'pattern': 'ascending_triangle',
                            'confidence': 0.75,
                            'resistance_level': np.mean(highs),
                            'support_trend': (np.mean(lows[-2:]) - np.mean(lows[:2])) / np.mean(lows[:2])
                        })
            except (IndexError, ValueError):
                continue

        return patterns

    def analyze_pattern_success(self, data, patterns, lookforward_days=10):
        """Analyze historical pattern success rates"""
        pattern_analysis = {
            'inverted_w': {'total': 0, 'successful': 0, 'avg_return': 0, 'success_conditions': []},
            'bullish_engulfing': {'total': 0, 'successful': 0, 'avg_return': 0, 'success_conditions': []},
            'ascending_triangle': {'total': 0, 'successful': 0, 'avg_return': 0, 'success_conditions': []}
        }

        data_with_indicators = self.calculate_technical_indicators(data.copy())

        for pattern in patterns:
            pattern_type = pattern['pattern']
            start_idx = pattern['start_idx']
            end_idx = pattern['end_idx']

            # Skip if not enough data for analysis
            if end_idx + lookforward_days >= len(data):
                continue

            pattern_analysis[pattern_type]['total'] += 1

            # Calculate return after pattern
            entry_price = data['Close'].iloc[end_idx]
            exit_price = data['Close'].iloc[end_idx + lookforward_days]
            return_pct = ((exit_price - entry_price) / entry_price) * 100

            # Analyze conditions at pattern formation
            pattern_conditions = self.analyze_pattern_conditions(data_with_indicators, start_idx, end_idx)

            # Consider pattern successful if return > 2%
            if return_pct > 2:
                pattern_analysis[pattern_type]['successful'] += 1
                pattern_analysis[pattern_type]['success_conditions'].append(pattern_conditions)

            pattern_analysis[pattern_type]['avg_return'] += return_pct

        # Calculate averages
        for pattern_type in pattern_analysis:
            if pattern_analysis[pattern_type]['total'] > 0:
                pattern_analysis[pattern_type]['avg_return'] /= pattern_analysis[pattern_type]['total']
                pattern_analysis[pattern_type]['success_rate'] = (
                    pattern_analysis[pattern_type]['successful'] / pattern_analysis[pattern_type]['total']
                ) * 100

        return pattern_analysis

    def analyze_pattern_conditions(self, data, start_idx, end_idx):
        """Analyze market conditions when pattern formed"""
        try:
            pattern_data = data.iloc[start_idx:end_idx+1]

            conditions = {
                'rsi_avg': pattern_data['RSI'].mean(),
                'rsi_oversold': (pattern_data['RSI'] < 30).any(),
                'above_sma20': (pattern_data['Close'] > pattern_data['SMA_20']).any(),
                'above_sma50': (pattern_data['Close'] > pattern_data['SMA_50']).any(),
                'macd_positive': (pattern_data['MACD'] > 0).any(),
                'macd_bullish_cross': self.detect_macd_bullish_cross(pattern_data),
                'volume_above_avg': (pattern_data['Volume_Ratio'] > 1.2).any(),
                'near_support': self.check_near_support(pattern_data),
                'breaking_resistance': self.check_resistance_break(pattern_data)
            }

            return conditions
        except:
            return {}

    def detect_macd_bullish_cross(self, data):
        """Detect MACD bullish crossover"""
        try:
            macd = data['MACD'].values
            signal = data['MACD_Signal'].values

            for i in range(1, len(macd)):
                if macd[i] > signal[i] and macd[i-1] <= signal[i-1]:
                    return True
            return False
        except:
            return False

    def check_near_support(self, data):
        """Check if price is near support level"""
        try:
            close_prices = data['Close'].values
            support_levels = data['Support'].values

            for i in range(len(close_prices)):
                if abs(close_prices[i] - support_levels[i]) / support_levels[i] < 0.02:
                    return True
            return False
        except:
            return False

    def check_resistance_break(self, data):
        """Check if price breaks resistance"""
        try:
            close_prices = data['Close'].values
            resistance_levels = data['Resistance'].values

            for i in range(len(close_prices)):
                if close_prices[i] > resistance_levels[i]:
                    return True
            return False
        except:
            return False

    def identify_bullish_conditions(self, pattern_analysis):
        """Identify what conditions lead to successful bullish patterns"""
        bullish_conditions = {}

        for pattern_type, analysis in pattern_analysis.items():
            if analysis['success_conditions']:
                # Analyze successful patterns
                successful_conditions = analysis['success_conditions']

                condition_stats = {
                    'rsi_oversold_rate': sum(1 for c in successful_conditions if c.get('rsi_oversold', False)) / len(successful_conditions) * 100,
                    'above_sma20_rate': sum(1 for c in successful_conditions if c.get('above_sma20', False)) / len(successful_conditions) * 100,
                    'above_sma50_rate': sum(1 for c in successful_conditions if c.get('above_sma50', False)) / len(successful_conditions) * 100,
                    'macd_positive_rate': sum(1 for c in successful_conditions if c.get('macd_positive', False)) / len(successful_conditions) * 100,
                    'macd_bullish_cross_rate': sum(1 for c in successful_conditions if c.get('macd_bullish_cross', False)) / len(successful_conditions) * 100,
                    'high_volume_rate': sum(1 for c in successful_conditions if c.get('volume_above_avg', False)) / len(successful_conditions) * 100,
                    'near_support_rate': sum(1 for c in successful_conditions if c.get('near_support', False)) / len(successful_conditions) * 100,
                    'resistance_break_rate': sum(1 for c in successful_conditions if c.get('breaking_resistance', False)) / len(successful_conditions) * 100,
                    'avg_rsi': np.mean([c.get('rsi_avg', 50) for c in successful_conditions if c.get('rsi_avg')])
                }

                bullish_conditions[pattern_type] = condition_stats

        return bullish_conditions

    def check_current_conditions(self, data):
        """Check current market conditions"""
        data_with_indicators = self.calculate_technical_indicators(data.copy())
        latest = data_with_indicators.iloc[-1]

        current_conditions = {
            'current_price': latest['Close'],
            'rsi': latest['RSI'],
            'rsi_oversold': latest['RSI'] < 30,
            'above_sma20': latest['Close'] > latest['SMA_20'],
            'above_sma50': latest['Close'] > latest['SMA_50'],
            'macd': latest['MACD'],
            'macd_positive': latest['MACD'] > 0,
            'macd_histogram': latest['MACD_Histogram'],
            'volume_ratio': latest['Volume_Ratio'],
            'high_volume': latest['Volume_Ratio'] > 1.2,
            'distance_to_support': ((latest['Close'] - latest['Support']) / latest['Support']) * 100,
            'distance_to_resistance': ((latest['Resistance'] - latest['Close']) / latest['Close']) * 100,
            'bb_position': self.get_bb_position(latest)
        }

        return current_conditions

    def get_bb_position(self, data_row):
        """Get position within Bollinger Bands"""
        try:
            if data_row['BB_Upper'] == data_row['BB_Lower']:
                return 0.5
            return (data_row['Close'] - data_row['BB_Lower']) / (data_row['BB_Upper'] - data_row['BB_Lower'])
        except:
            return 0.5

    def generate_bullish_recommendations(self, current_conditions, bullish_conditions, pattern_analysis):
        """Generate recommendations for bullish setup"""
        recommendations = []

        # Check RSI conditions
        if current_conditions['rsi'] > 30:
            recommendations.append("‚ö†Ô∏è RSI not in oversold territory (current: {:.1f}). Wait for RSI < 30 for better entry.".format(current_conditions['rsi']))
        else:
            recommendations.append("‚úÖ RSI oversold (current: {:.1f}) - Good for reversal patterns.".format(current_conditions['rsi']))

        # Check moving average conditions
        if not current_conditions['above_sma20']:
            recommendations.append("‚ö†Ô∏è Price below 20 SMA. Need price above ‚Çπ{:.2f} for bullish confirmation.".format(current_conditions['current_price'] * 1.02))

        if not current_conditions['above_sma50']:
            recommendations.append("‚ö†Ô∏è Price below 50 SMA. Long-term trend still bearish.")

        # Check MACD conditions
        if current_conditions['macd'] <= 0:
            recommendations.append("‚ö†Ô∏è MACD negative ({:.2f}). Wait for MACD to turn positive.".format(current_conditions['macd']))

        if current_conditions['macd_histogram'] <= 0:
            recommendations.append("‚ö†Ô∏è MACD histogram negative. Wait for bullish MACD crossover.")

        # Check volume
        if not current_conditions['high_volume']:
            recommendations.append("‚ö†Ô∏è Volume below average ({:.2f}x). Need volume surge above 1.5x for confirmation.".format(current_conditions['volume_ratio']))

        # Support/Resistance analysis
        if current_conditions['distance_to_resistance'] < 3:
            recommendations.append("‚ö†Ô∏è Too close to resistance. Only {:.1f}% upside to resistance level.".format(current_conditions['distance_to_resistance']))

        if current_conditions['distance_to_support'] < 2:
            recommendations.append("‚úÖ Near support level. Good risk-reward setup.")

        # Bollinger Bands position
        bb_pos = current_conditions['bb_position']
        if bb_pos < 0.2:
            recommendations.append("‚úÖ Price in lower Bollinger Band ({}%). Good for reversal.".format(int(bb_pos * 100)))
        elif bb_pos > 0.8:
            recommendations.append("‚ö†Ô∏è Price in upper Bollinger Band ({}%). Overbought territory.".format(int(bb_pos * 100)))

        return recommendations

    # Keep existing methods for pattern detection and model training
    def create_pattern_features(self, prices):
        """Create 2D pattern representation"""
        try:
            normalized_prices = self.scaler.fit_transform(prices.reshape(-1, 1)).flatten()

            n = min(len(normalized_prices), self.window_size)
            feature_matrix = np.zeros((self.window_size, self.window_size))

            for i in range(self.window_size):
                for j in range(self.window_size):
                    if i < n and j < n:
                        feature_matrix[i, j] = normalized_prices[i] * normalized_prices[j]
                    elif i < n:
                        feature_matrix[i, j] = normalized_prices[i] * normalized_prices[-1]
                    elif j < n:
                        feature_matrix[i, j] = normalized_prices[-1] * normalized_prices[j]
                    else:
                        feature_matrix[i, j] = normalized_prices[-1] * normalized_prices[-1]

            return feature_matrix
        except Exception:
            return np.zeros((self.window_size, self.window_size))

    def create_training_data(self, data, patterns):
        """Create training data from patterns"""
        prices = data['Close'].values
        features, labels = [], []

        for pattern in patterns:
            start_idx = pattern['start_idx']

            if start_idx >= 0 and start_idx + self.window_size <= len(prices):
                pattern_prices = prices[start_idx:start_idx + self.window_size]
                if len(pattern_prices) == self.window_size:
                    feature_matrix = self.create_pattern_features(pattern_prices)
                    features.append(feature_matrix)
                    labels.append(1)

        num_negative = min(len(features), 50)
        for _ in range(num_negative):
            max_start = len(prices) - self.window_size
            if max_start > 0:
                start_idx = np.random.randint(0, max_start)

                is_pattern = False
                for pattern in patterns:
                    if not (start_idx + self.window_size <= pattern['start_idx'] or
                           start_idx >= pattern['end_idx']):
                        is_pattern = True
                        break

                if not is_pattern:
                    random_prices = prices[start_idx:start_idx + self.window_size]
                    if len(random_prices) == self.window_size:
                        feature_matrix = self.create_pattern_features(random_prices)
                        features.append(feature_matrix)
                        labels.append(0)

        return np.array(features), np.array(labels)

    def build_pattern_model(self):
        """Build CNN for pattern recognition"""
        model = Sequential([
            Conv2D(16, (3, 3), activation='relu', input_shape=(self.window_size, self.window_size, 1)),
            MaxPooling2D((2, 2)),
            Conv2D(32, (3, 3), activation='relu'),
            MaxPooling2D((2, 2)),
            Flatten(),
            Dense(32, activation='relu'),
            Dropout(0.5),
            Dense(1, activation='sigmoid')
        ])

        model.compile(optimizer=Adam(learning_rate=0.001),
                     loss='binary_crossentropy',
                     metrics=['accuracy'])
        return model

    def build_forecast_model(self):
        """Build LSTM for forecasting"""
        model = Sequential([
            LSTM(25, return_sequences=True, input_shape=(self.window_size, 1)),
            Dropout(0.2),
            LSTM(25),
            Dropout(0.2),
            Dense(12),
            Dense(1)
        ])

        model.compile(optimizer=Adam(learning_rate=0.001), loss='mse')
        return model

    def prepare_forecast_data(self, data):
        """Prepare data for price forecasting"""
        prices = data['Close'].values.reshape(-1, 1)
        if self.scaler is not None:
            scaled_prices = self.scaler.fit_transform(prices)
            self._manual_scaler = None
        else:
            # Fallback min-max scaling if sklearn not installed
            minv = float(np.min(prices))
            maxv = float(np.max(prices))
            if maxv == minv:
                scaled_prices = np.zeros_like(prices)
            else:
                scaled_prices = (prices - minv) / (maxv - minv)
            self._manual_scaler = (minv, maxv)

        X, y = [], []
        for i in range(self.window_size, len(scaled_prices)-1):
            X.append(scaled_prices[i-self.window_size:i, 0])
            y.append(scaled_prices[i, 0])

        return np.array(X), np.array(y)

    def train_models(self, data):
        """Train both models"""
        print("\nüîç Detecting patterns...")

        inv_w_patterns = self.detect_inverted_w_pattern(data['Close'].values)
        engulfing_patterns = self.detect_bullish_engulfing(data)
        triangle_patterns = self.detect_ascending_triangle(data['Close'].values)

        all_patterns = inv_w_patterns + engulfing_patterns + triangle_patterns
        print(f"‚úÖ Found {len(all_patterns)} total patterns")

        if len(all_patterns) == 0:
            print("‚ùå No patterns found for training")
            return all_patterns

        # Train pattern recognition model
        print("\nüß† Training pattern recognition model...")
        if not (_HAS_SKLEARN and _HAS_TF):
            print("‚ö†Ô∏è Skipping pattern model training: scikit-learn or TensorFlow not available.")
        else:
            features, labels = self.create_training_data(data, all_patterns)

            if len(features) > 10:
                X_train, X_test, y_train, y_test = train_test_split(
                    features, labels, test_size=0.2, random_state=42
                )

                X_train = X_train.reshape(X_train.shape[0], self.window_size, self.window_size, 1)
                X_test = X_test.reshape(X_test.shape[0], self.window_size, self.window_size, 1)

                self.pattern_model = self.build_pattern_model()

                history = self.pattern_model.fit(
                    X_train, y_train,
                    validation_data=(X_test, y_test),
                    epochs=50,
                    batch_size=16,
                    verbose=0
                )

                final_acc = history.history.get('accuracy', [None])[-1]
                final_val_acc = history.history.get('val_accuracy', [None])[-1]
                try:
                    print(f"‚úÖ Pattern model trained - Accuracy: {final_acc:.3f}, Val Accuracy: {final_val_acc:.3f}")
                except Exception:
                    print("‚úÖ Pattern model trained")

        # Train forecasting model
        print("\nüìà Training forecasting model...")
        if not _HAS_TF:
            print("‚ö†Ô∏è Skipping forecast model training: TensorFlow not available.")
        else:
            X_forecast, y_forecast = self.prepare_forecast_data(data)

            if len(X_forecast) > 20:
                X_train_f, X_test_f, y_train_f, y_test_f = train_test_split(
                    X_forecast, y_forecast, test_size=0.2, random_state=42
                )

                X_train_f = X_train_f.reshape((X_train_f.shape[0], X_train_f.shape[1], 1))
                X_test_f = X_test_f.reshape((X_test_f.shape[0], X_test_f.shape[1], 1))

                self.forecast_model = self.build_forecast_model()

                self.forecast_model.fit(
                    X_train_f, y_train_f,
                    validation_data=(X_test_f, y_test_f),
                    epochs=50,
                    batch_size=16,
                    verbose=0
                )

                print("‚úÖ Forecast model trained")

        return all_patterns

    def forecast_prices(self, data, days_ahead=5):
        """Generate price forecast"""
        if self.forecast_model is None:
            return None

        prices = data['Close'].values
        last_window = prices[-self.window_size:]
        scaled_window = self.scaler.fit_transform(last_window.reshape(-1, 1))

        forecasts = []
        current_window = scaled_window.flatten()

        for _ in range(days_ahead):
            X_pred = current_window[-self.window_size:].reshape(1, self.window_size, 1)
            next_price = self.forecast_model.predict(X_pred, verbose=0)[0][0]
            forecasts.append(next_price)
            current_window = np.append(current_window, next_price)

        forecast_prices = self.scaler.inverse_transform(np.array(forecasts).reshape(-1, 1)).flatten()
        return forecast_prices

    def plot_enhanced_analysis(self, data, patterns, forecast, current_conditions):
        """Create enhanced analysis chart with fixed legend"""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(20, 12))

        # Main price chart with indicators
        data_with_indicators = self.calculate_technical_indicators(data.copy())

        ax1.plot(data.index, data['Close'], label='CDSL Close Price', color='blue', linewidth=1.5)
        ax1.plot(data.index, data_with_indicators['SMA_20'], label='SMA 20', color='orange', alpha=0.7)
        ax1.plot(data.index, data_with_indicators['SMA_50'], label='SMA 50', color='red', alpha=0.7)

        # Mark patterns - Fixed legend issue
        pattern_colors = {'inverted_w': 'green', 'bullish_engulfing': 'orange', 'ascending_triangle': 'purple'}
        pattern_labels_added = set()  # Track which pattern labels we've already added

        for pattern in patterns:
            start_idx = max(0, pattern['start_idx'])
            end_idx = min(len(data), pattern['end_idx'])

            if start_idx < len(data) and end_idx <= len(data):
                color = pattern_colors.get(pattern['pattern'], 'red')
                pattern_name = pattern['pattern'].replace('_', ' ').title()

                # Only add label if we haven't added it before
                if pattern['pattern'] not in pattern_labels_added:
                    ax1.axvspan(data.index[start_idx], data.index[end_idx-1],
                               alpha=0.3, color=color, label=pattern_name)
                    pattern_labels_added.add(pattern['pattern'])
                else:
                    # Same pattern type, no label to avoid duplicates
                    ax1.axvspan(data.index[start_idx], data.index[end_idx-1],
                               alpha=0.3, color=color)

        # Add forecast
        if forecast is not None:
            last_date = data.index[-1]
            forecast_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=len(forecast))
            ax1.plot(forecast_dates, forecast, 'r--', label='5-Day Forecast', linewidth=2, marker='o')

        ax1.set_title('CDSL - Enhanced Pattern Analysis & Price Forecast', fontsize=14, fontweight='bold')
        ax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        ax1.grid(True, alpha=0.3)

        # RSI chart
        ax2.plot(data.index, data_with_indicators['RSI'], color='purple', linewidth=1.5)
        ax2.axhline(y=70, color='r', linestyle='--', alpha=0.7, label='Overbought (70)')
        ax2.axhline(y=30, color='g', linestyle='--', alpha=0.7, label='Oversold (30)')
        ax2.fill_between(data.index, 30, 70, alpha=0.1, color='gray')
        ax2.set_title('RSI (14)', fontsize=12)
        ax2.set_ylim(0, 100)
        ax2.legend()
        ax2.grid(True, alpha=0.3)

        # MACD chart
        ax3.plot(data.index, data_with_indicators['MACD'], label='MACD', color='blue', linewidth=1.5)
        ax3.plot(data.index, data_with_indicators['MACD_Signal'], label='Signal', color='red', linewidth=1.5)
        ax3.bar(data.index, data_with_indicators['MACD_Histogram'], label='Histogram', alpha=0.6, color='gray')
        ax3.axhline(y=0, color='black', linestyle='-', alpha=0.5)
        ax3.set_title('MACD', fontsize=12)
        ax3.legend()
        ax3.grid(True, alpha=0.3)

        # Volume chart
        ax4.bar(data.index, data['Volume'], alpha=0.7, color='gray')
        ax4.plot(data.index, data_with_indicators['Volume_SMA'], color='red', linewidth=2, label='Volume SMA(20)')
        ax4.set_title('Trading Volume', fontsize=12)
        ax4.legend()
        ax4.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def analyze_cdsl_enhanced(self):
        """Complete enhanced CDSL analysis"""
        print("üöÄ Enhanced CDSL Pattern Recognition & Forecasting System")
        print("=" * 65)

        # Fetch extended data
        data = self.fetch_data('EDELWEISS.NS', period='2y')
        if data is None:
            print("‚ùå Could not fetch manskind data")
            return

        # Train models and get patterns
        all_patterns = self.train_models(data)

        if not all_patterns:
            print("‚ùå No patterns found for analysis")
            return

        # Analyze historical pattern success
        print("\nüìä Analyzing historical pattern performance...")
        pattern_analysis = self.analyze_pattern_success(data, all_patterns)

        # Identify bullish conditions
        bullish_conditions = self.identify_bullish_conditions(pattern_analysis)

        # Check current market conditions
        current_conditions = self.check_current_conditions(data)

        # Generate recommendations
        recommendations = self.generate_bullish_recommendations(current_conditions, bullish_conditions, pattern_analysis)

        # Detect current patterns
        inv_w = self.detect_inverted_w_pattern(data['Close'].values)
        engulfing = self.detect_bullish_engulfing(data)
        triangle = self.detect_ascending_triangle(data['Close'].values)
        current_patterns = inv_w + engulfing + triangle

        # Generate forecast
        forecast = self.forecast_prices(data, days_ahead=5)

        # Display results
        self.display_enhanced_results(data, current_patterns, forecast, pattern_analysis,
                                    bullish_conditions, current_conditions, recommendations)

        # Create visualization
        print(f"\nüìà Generating enhanced analysis chart...")
        self.plot_enhanced_analysis(data, current_patterns, forecast, current_conditions)

        print("\n‚úÖ Enhanced analysis complete!")
        return data, current_patterns, forecast, pattern_analysis, bullish_conditions

    def display_enhanced_results(self, data, patterns, forecast, pattern_analysis,
                               bullish_conditions, current_conditions, recommendations):
        """Display comprehensive analysis results"""
        print("\n" + "="*65)
        print("üìä ENHANCED CDSL ANALYSIS RESULTS")
        print("="*65)

        current_price = data['Close'].iloc[-1]
        print(f"üí∞ Current Price: ‚Çπ{current_price:.2f}")

        # Current patterns
        inv_w_current = [p for p in patterns if p['pattern'] == 'inverted_w']
        engulfing_current = [p for p in patterns if p['pattern'] == 'bullish_engulfing']
        triangle_current = [p for p in patterns if p['pattern'] == 'ascending_triangle']

        print(f"\nüìà Current Patterns Detected:")
        print(f"   ‚Ä¢ Inverted W (Double Bottom): {len(inv_w_current)}")
        print(f"   ‚Ä¢ Bullish Engulfing: {len(engulfing_current)}")
        print(f"   ‚Ä¢ Ascending Triangle: {len(triangle_current)}")
        print(f"   ‚Ä¢ Total Bullish Patterns: {len(patterns)}")

        # Historical pattern performance
        print(f"\nüìä Historical Pattern Performance Analysis:")
        print("-" * 50)

        for pattern_type, analysis in pattern_analysis.items():
            if analysis['total'] > 0:
                pattern_name = pattern_type.replace('_', ' ').title()
                print(f"\n{pattern_name}:")
                print(f"   ‚Ä¢ Total Historical Occurrences: {analysis['total']}")
                print(f"   ‚Ä¢ Success Rate: {analysis.get('success_rate', 0):.1f}%")
                print(f"   ‚Ä¢ Average Return: {analysis['avg_return']:.2f}%")
                print(f"   ‚Ä¢ Successful Trades: {analysis['successful']}")

        # Bullish conditions analysis
        print(f"\nüéØ What Makes Patterns Successful (Bullish Conditions):")
        print("-" * 55)

        for pattern_type, conditions in bullish_conditions.items():
            pattern_name = pattern_type.replace('_', ' ').title()
            print(f"\n{pattern_name} Success Factors:")
            print(f"   ‚Ä¢ RSI Oversold: {conditions.get('rsi_oversold_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ Above 20 SMA: {conditions.get('above_sma20_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ Above 50 SMA: {conditions.get('above_sma50_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ MACD Positive: {conditions.get('macd_positive_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ MACD Bullish Cross: {conditions.get('macd_bullish_cross_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ High Volume: {conditions.get('high_volume_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ Near Support: {conditions.get('near_support_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ Breaking Resistance: {conditions.get('resistance_break_rate', 0):.0f}% of successful cases")
            print(f"   ‚Ä¢ Optimal RSI Range: {conditions.get('avg_rsi', 50):.1f}")

        # Current market conditions
        print(f"\nüîç Current Market Conditions:")
        print("-" * 35)
        print(f"   ‚Ä¢ RSI: {current_conditions['rsi']:.1f} {'(Oversold)' if current_conditions['rsi_oversold'] else '(Normal)'}")
        print(f"   ‚Ä¢ Price vs SMA20: {'Above' if current_conditions['above_sma20'] else 'Below'}")
        print(f"   ‚Ä¢ Price vs SMA50: {'Above' if current_conditions['above_sma50'] else 'Below'}")
        print(f"   ‚Ä¢ MACD: {current_conditions['macd']:.2f} {'(Positive)' if current_conditions['macd_positive'] else '(Negative)'}")
        print(f"   ‚Ä¢ MACD Histogram: {current_conditions['macd_histogram']:.2f}")
        print(f"   ‚Ä¢ Volume Ratio: {current_conditions['volume_ratio']:.2f}x avg")
        print(f"   ‚Ä¢ Distance to Support: {current_conditions['distance_to_support']:.1f}%")
        print(f"   ‚Ä¢ Distance to Resistance: {current_conditions['distance_to_resistance']:.1f}%")
        print(f"   ‚Ä¢ Bollinger Band Position: {current_conditions['bb_position']*100:.0f}%")

        # Forecast
        if forecast is not None:
            avg_forecast = np.mean(forecast)
            price_change = ((avg_forecast - current_price) / current_price) * 100

            print(f"\nüîÆ 5-Day Forecast:")
            for i, price in enumerate(forecast, 1):
                change = ((price - current_price) / current_price) * 100
                print(f"   Day {i}: ‚Çπ{price:.2f} ({change:+.2f}%)")

            print(f"\nüìä Forecast Summary:")
            print(f"   ‚Ä¢ Average Target: ‚Çπ{avg_forecast:.2f}")
            print(f"   ‚Ä¢ Expected Change: {price_change:+.2f}%")

            if price_change > 3:
                signal = "üöÄ STRONG BULLISH"
            elif price_change > 1:
                signal = "üìà BULLISH"
            elif price_change > -1:
                signal = "‚û°Ô∏è NEUTRAL"
            else:
                signal = "üìâ BEARISH"

            print(f"   ‚Ä¢ Signal: {signal}")

        # Recommendations for bullish setup
        print(f"\nüí° RECOMMENDATIONS FOR BULLISH SETUP:")
        print("=" * 45)

        if not recommendations:
            print("‚úÖ All conditions look favorable for bullish patterns!")
        else:
            for i, rec in enumerate(recommendations, 1):
                print(f"{i}. {rec}")

        # Key levels to watch
        print(f"\nüéØ KEY LEVELS TO WATCH:")
        print("-" * 25)
        print(f"   ‚Ä¢ Support Level: ‚Çπ{current_conditions['current_price'] * (1 - current_conditions['distance_to_support']/100):.2f}")
        print(f"   ‚Ä¢ Resistance Level: ‚Çπ{current_conditions['current_price'] * (1 + current_conditions['distance_to_resistance']/100):.2f}")
        print(f"   ‚Ä¢ 20 SMA: ‚Çπ{current_conditions['current_price'] / (1 if current_conditions['above_sma20'] else 1.02):.2f}")
        print(f"   ‚Ä¢ 50 SMA: ‚Çπ{current_conditions['current_price'] / (1 if current_conditions['above_sma50'] else 1.05):.2f}")

        # Trading strategy
        print(f"\nüìà SUGGESTED TRADING STRATEGY:")
        print("-" * 32)

        if len(patterns) > 0 and current_conditions['rsi'] < 40:
            print("‚úÖ ACCUMULATION PHASE:")
            print("   ‚Ä¢ Patterns detected with oversold RSI")
            print("   ‚Ä¢ Consider gradual accumulation near support")
            print("   ‚Ä¢ Wait for volume confirmation")
            print("   ‚Ä¢ Set stop loss below recent swing low")
        elif len(patterns) > 0:
            print("‚ö†Ô∏è WAIT FOR BETTER ENTRY:")
            print("   ‚Ä¢ Patterns present but RSI not oversold")
            print("   ‚Ä¢ Wait for pullback to support levels")
            print("   ‚Ä¢ Monitor for MACD bullish crossover")
        else:
            print("‚è≥ NO CLEAR PATTERNS:")
            print("   ‚Ä¢ Wait for clearer pattern formation")
            print("   ‚Ä¢ Monitor key support/resistance levels")
            print("   ‚Ä¢ Watch for volume increase")

# Run Enhanced CDSL Analysis
if __name__ == "__main__":
    analyzer = EnhancedCDSLPatternAnalyzer()
    data, patterns, forecast, pattern_analysis, bullish_conditions = analyzer.analyze_cdsl_enhanced()


def detect(data=None):
    """Module-level lightweight detection shim.
    Accepts a pandas DataFrame or a ticker symbol string. Returns a dict with
    'patterns' and optional 'forecast'."""
    try:
        analyzer = EnhancedCDSLPatternAnalyzer()

        df = None
        if isinstance(data, pd.DataFrame):
            df = data
        elif isinstance(data, str):
            df = analyzer.fetch_data(data)
        else:
            # No data provided ‚Äî attempt to fetch a default symbol
            try:
                df = analyzer.fetch_data()
            except Exception:
                df = None

        if df is None:
            return {'patterns': [], 'forecast': None}

        patterns = analyzer.train_models(df)

        forecast = None
        try:
            if _HAS_TF and analyzer.forecast_model is not None:
                forecast = analyzer.forecast_prices(df, days_ahead=5)
        except Exception:
            forecast = None

        return {'patterns': patterns, 'forecast': forecast}
    except Exception as e:
        return {'error': str(e), 'patterns': [], 'forecast': None}


def detect_pattern(data=None):
    """Backward-compatible alias for detect()."""
    return detect(data)